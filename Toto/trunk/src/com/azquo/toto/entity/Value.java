package com.azquo.toto.entity;

import com.azquo.toto.memorydb.TotoMemoryDB;

import java.util.*;

/**
 * Created with IntelliJ IDEA.
 * User: cawley
 * Date: 22/10/13
 * Time: 22:31
 * To reflect a fundamental Toto idea : a piece of data which has labels attached
 * Delete should be updatable and I'll make the labels as well for the moment
 */
public class Value extends StandardEntity{

    // leaving here as a reminder to consider proper logging

    //private static final Logger logger = Logger.getLogger(Value.class.getName());
    // this is stored in the DB as an int from .ordinal() so WATCH OUT changing orders here
    public enum Type {INT, DOUBLE, VARCHAR, TEXT, TIMESTAMP}

    private int provenanceId;
    private Type type;
    private int intValue;
    private double doubleValue;
    private String varChar;
    private String text;
    private Date timeStamp;
    private boolean deleted;

    private Set<Label> labels;
    boolean labelsChanged;


    // TODO : make new memory db pay attention to deleted!

    public Value(int id, int provenanceId, Type type, int intValue, double doubleValue, String varChar, String text, Date timeStamp, boolean deleted) {
        this.id = id;
        this.provenanceId = provenanceId;
        this.type = type;
        this.intValue = intValue;
        this.doubleValue = doubleValue;
        this.varChar = varChar;
        this.text = text;
        this.timeStamp = timeStamp;
        this.deleted = deleted;
        labels = new HashSet<Label>();
        labelsChanged = false;
    }

    public int getProvenanceId() {
        return provenanceId;
    }

    public Type getType() {
        return type;
    }

    public int getIntValue() {
        return intValue;
    }

    public double getDoubleValue() {
        return doubleValue;
    }

    public String getVarChar() {
        return varChar;
    }

    public String getText() {
        return text;
    }

    public Date getTimeStamp() {
        return timeStamp;
    }


    public boolean getDeleted() {
        return deleted;
    }

    //

    public synchronized void setDeletedWillBePersisted(boolean deleted)
    {
        if (this.deleted != deleted){
            this.deleted = deleted;
            entityColumnsChanged = true;
            inspectForPersistence = true;
        }
    }
    // Generated by Intellij, Dr. Mike thinks it a good idea, I'll follow suit
    // it's worth noting that if we start using sets and the like in anger then hash code and equals may become significant . . .
    // TODO : watch out on this :)

    @Override
    public int hashCode() {
        int result;
        long temp;
        result = provenanceId;
        result = 31 * result + (type != null ? type.hashCode() : 0);
        result = 31 * result + intValue;
        temp = Double.doubleToLongBits(doubleValue);
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        result = 31 * result + (varChar != null ? varChar.hashCode() : 0);
        result = 31 * result + (text != null ? text.hashCode() : 0);
        result = 31 * result + (timeStamp != null ? timeStamp.hashCode() : 0);
        // add deleted . . do we care?
        return result;
    }

    @Override
    public String toString() {
        return "Value{" +
                "id=" + id +
                ", changeId=" + provenanceId +
                ", type=" + type +
                ", intValue=" + intValue +
                ", doubleValue=" + doubleValue +
                ", varChar='" + varChar + '\'' +
                ", text='" + text + '\'' +
                ", timeStamp=" + timeStamp +
                ", deleted=" + deleted+
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true; // this should do the job fo much of the memory db matching
        if (o == null || getClass() != o.getClass()) return false;

        Value value = (Value) o;

        if (deleted != value.deleted) return false;
        if (Double.compare(value.doubleValue, doubleValue) != 0) return false;
        if (intValue != value.intValue) return false;
        if (labelsChanged != value.labelsChanged) return false;
        if (provenanceId != value.provenanceId) return false;
        if (labels != null ? !labels.equals(value.labels) : value.labels != null) return false;
        if (text != null ? !text.equals(value.text) : value.text != null) return false;
        if (timeStamp != null ? !timeStamp.equals(value.timeStamp) : value.timeStamp != null) return false;
        if (type != value.type) return false;
        if (varChar != null ? !varChar.equals(value.varChar) : value.varChar != null) return false;

        return true;
    }

    public Set<Label> getLabels() {
        return Collections.unmodifiableSet(labels);
    }

    public synchronized void setLabelsWillBePersisted(Set<Label> labels) {
        this.labels = labels;
        labelsChanged = true;
        inspectForPersistence = true;
    }


    // used after database load and saves
    @Override
    public void syncedToDB(){
        super.syncedToDB();
        labelsChanged = false;
    }
}
